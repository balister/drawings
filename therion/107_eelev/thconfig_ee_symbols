encoding  utf-8
layout symbols

  code metapost
#     let l_floorstep = l_ceilingstep_UIS;
 #    let l_pit = l_ceilingstep_UIS;
     let p_clay = p_flowstone_UIS;
     let l_wall_debris = l_wall_debris_AUT;
     let l_wall_blocks = l_wall_blocks_AUT;
     
   def l_survey_cave (expr p) =
    pickup PenC;
    draw p withcolor 1.5red;
  enddef;
  
      beginpattern(pattern_water);
      draw origin--10up withpen pensquare scaled (0.03u); % line thickness
      patternxstep(.3u);                                 % spacing
      patterntransform(identity rotated 45);
  endpattern;
  
  def a_water (expr Path) =
  %Bruce Mutton 2010.06.20 for Therion 5.3.8
    T:=identity;
    thclean  Path;
    pickup PenD;
    thfill Path withcolor (0.1, 0.2, 0.8);
    thfill Path withpattern pattern_water; 
  enddef;
    
        beginpattern(pattern_mud);
        pickup PenC;
        p:=(.0u,.0u) -- (0.25u,.0u);
        for i=0.0u step 0.9u until 5.4u:
            for j=0.0u step 0.9u until 5.4u:
                draw p shifted ((i,j) randomized 0.2u);
                draw p shifted ((i+.3u,j+.3u) randomized 0.2u);
            endfor;
        endfor;
        patternstep(5.4u,5.4u);
    endpattern;

    def a_clay (expr p) =
        T:=identity;
        thfill p withcolor (0.8,0.5,0.3);
        thfill p withpattern pattern_mud;
    enddef;
    
  beginpattern(pattern_sand);
    pickup PenC;
    p:= origin -- (0.01u,0.01u);
    for i=0.0u step 0.5u until 2.5u:  %AUT is step 0.2u 
      for j=0.0u step 0.5u until 2.5u:  %AUT is step 0.2u 
        draw p rotated uniformdeviate(360) 
         shifted ((i,j) randomized 0.4u);  %%AUT is 0.09u
      endfor;
    endfor;
    if BaseScale<=2.5:
        my_step:=2.6u;  %mystep controls tessilation pattern, must synchronise with i, j above, was 2.4u
    else:
        my_step:=2.8u;  %was 2.6u
    fi;
    patternstep(my_step,my_step);       
  endpattern;

  def a_sand (expr Path) =
    T:=identity;
    thfill Path withpattern pattern_sand ;
  enddef;
  
 def  l_wall_clay (expr P) = 
   T:=identity;
  cas := 0;
  dlzka := arclength P;
  mojkrok:=adjust_step(dlzka, .9u);
  pickup PenC;
  p := (-.2u,0)--(.2u,0);
  forever:
 #   t := arctime (cas + mojkrok/2) of P;
    t := arctime cas of P;
    thdraw p shifted (point t of P + .35u * unitvector(thdir(P,t) rotated -90));
    cas := cas + mojkrok;
    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
  endfor;
  pickup PenA;  
  thdraw P;
 enddef; 

  # Adapted from Thomas Holder's
 def s_scalebar (expr l, units, txt) =
  begingroup
    interim warningcheck:=0;
    tmpl:=l / Scale * cm * units / 2;
    tmpx:=l / Scale * cm * units / 5;
    tmph:=5bp; % bar height
  endgroup;
  pickup PenC;
  draw (-tmpl,0)--(tmpl,0);
  p:=(0,0)--(0,-tmph);
  for i:=-2.5 step 1 until 2.5:
    draw p shifted (i * tmpx,0);
  endfor;
  begingroup
    interim labeloffset:=3.5bp;
    for i:=0 step (l/5) until (l-1):
      tmpx:=tmpl * (i * 2 / l - 1);
      label.bot(thTEX(decimal (i)),(tmpx,-tmph));
    endfor;
    label.bot(thTEX(decimal (l) & "\thinspace" & txt),(tmpl,-tmph));
    label.top(thTEX("Original Scale 1:" & decimal round(Scale*100)),(0,0));
  endgroup;
enddef; 

   endcode

endlayout
